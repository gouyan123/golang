import "fmt"：只有全局对象才能在任何地方之间使用，例如 len(list) len()为全局函数，可直接使用，不用导入，
但 fmt不是全局对象，需要导入当前模块/文件才能使用；
1、传值与传指针：
传值：都会在A函数的函数栈内开辟空间复制这个值，一旦退出该函数，针对A函数对m的操作都会实现，因为A函数内的 m是对 A函数参数 m的复制；
func add(a int)(int)  {
	a = a + 1;
	return a;
}
func main()  {
	a := 1;
	var b int;
	b = add(a);
	fmt.Print(a,b);
}
返回：1,2
传指针：
func add(a *int)(int)  {    * 使用 a 的地址
	*a = *a + 1;
	return *a;
}
func main()  {
	a := 1;
	var b int;
	b = add(&a);            & 获得a的地址
	fmt.Print(a,b);
}
2、接口赋值
将对象实例赋值给接口；
将一个接口赋值给另一个接口；
Any类型：Go语言中任何对象实例都满足空接口 interface{}，类似java中Object，例如，var v1 interface{} = 1;
var v1 interface{} = "abc"; var v1 interface{} = make(map[...]);
空接口也用于参数广泛接收：func Print(fmt string,args ...interface{});
主要用于声明变量类型：var v1 interface{};  v1 = 6.78;
/*接口*/
type Animal interface {
	fly();
	run();
}
/*类，类不用实现接口，覆写接口方法时，指定类就行*/
type Bird struct{

}
/*覆写接口方法fly()，指定具体实现类Bird*/
func (bird Bird) fly(){
	fmt.Println("鸟会飞");
}
/*覆写接口方法run()，指定具体实现类Bird*/
func (bird Bird)run(){
	fmt.Println("鸟会跑");
}
func main()  {
	/* := 代表声明变量并赋值；= 代表赋值*/
	/*go语言中，声明的变量一定要使用，否则删掉，要不然会报错*/
	var animal Animal;
	bird := new(Bird);
	animal = bird;
	animal.fly();
	animal.run();
}

3、函数接收到 interface{}，要根据其实际不同类型类型，做处理，go中提供类型查询：
if_,ok := a.(*Integer);ok
    {
        ...
    }
v1.type
----------------------------函数------------------
不定参数类型函数：args代表参数名称 ...int代表参数类型
func myFunc(args ...int){
    for i,value := range args{   rang遍历args返回 2 个参数 i,value 下标,值
        ...
    }
}
不定参数作为实参 传递参数：
args[0,1,2]代表只传递第 0 1 2 个，args[1:3]代表传递第 1 2 3 个，args[:3]代表只传递第 0 1 2 3

有返回值的函数定义：
func myFunc(paramType paramName)(int,int){  返回只指定类型，不用指定名称
    x := 1;
    y := 2;
    return x,y;
}

函数类型：
在Go语言中，函数也是一种类型，可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一直类型；实质函数类型就是函数指针；

回调函数：
函数参数是函数类型，这个函数类型就是回调函数；

匿名函数和闭包：
闭包依赖匿名函数，匿名函数就是一个函数引用地址，要调用需加();
闭包以引用的形式使用外部函数的变量；
    所谓闭包，就是一个函数 捕获 了和它在同一作用域的其他常量或者变量。这就意味着当闭包被调用的时候，不管闭包
函数在什么地方被调用，闭包函数都能够使用这些常量或者变量，只有闭包函数还在使用这些变量或常量，这些变量就
还会存在。
    在Go语言中，所有的匿名函数都是闭包，匿名函数是指不需要函数名的一种函数实现形式；

5.6 延迟调用defer
5.6.1 defer作用
类似于面向对象编程中的析构函数，在函数被调用 执行 完毕之前 做一些清理工作，defer语句只能出现在函数或方法
内部，在函数或者方法结束前一刹那调用执行 defer；
5.6.2 多个defer执行顺序
如果一个函数中有多个defer，它们以LIFO（先进后出）的顺序执行，哪怕函数或某个延迟发生错误，这些调用依旧会
被执行；函数或方法中没有 defer 语句时，程序会停止在发生异常的地方，不再继续执行；
5.6.3 延迟调用defer结合匿名函数(就是一个函数引用)
func main(){
	a := 10
	b := 20
	defer func(){
		fmt.Printf("内部 a = %d,b = %d\n",a,b)
	}()
	a = 111
	b = 222
	fmt.Printf("外部 a = %d,b = %d\n",a,b)
}
返回结果：
外部 a = 111,b = 222
内部 a = 111,b = 222
func main(){
	a := 10
	b := 20
	defer func(a int,b int){
		fmt.Printf("内部 a = %d,b = %d\n",a,b)
	}(a,b)
	a = 111
	b = 222
	fmt.Printf("外部 a = %d,b = %d\n",a,b)
}
返回结果：
外部 a = 111,b = 222
内部 a = 10,b = 20

5.7 获取命令行参数

5.8 作用域
作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围
5.8.1 局部变量
在函数体内声明的变量、参数和返回值变量就是局部变量，它们的作用域只在函数体内
5.8.2 全局变量
在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用
5.8.3 不同作用域同名变量
在不同作用域可以声明同名的变量，其访问原则为：在同一个作用域内，就近原则访问最近的变量，如果此作用域没有
此变量声明，则访问全局变量，如果全局变量也没有，则报错

6. 工程管理（编译 Go命令行工具通过目录结构和包名来推到编译）
在实际的开发工作中，直接调用编译器进行编译和链接的场景是少而又少，因为在工程中不会简单到只有一个源代码文
件，且源文件之间会有相互的依赖关系。如果这样一个文件一个文件逐步编译，那不亚于一场灾难。 Go语言的设计者作
为行业老将，自然不会忽略这一点。早期Go语言使用makefile作为临时方案，到了Go 1发布时引入了强大无比的Go命令
行工具。 Go命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推导工程结构和构建顺
序。针对只有一个源文件的情况讨论工程管理看起来会比较多余，因为这可以直接用go run和go build搞定。下面我们
将用一个更接近现实的虚拟项目来展示Go语言的基本工程管理方法。

总结：
1、方法首字母必须大写，才能够被别人引用；
2、import "fmt"导入fmt包（导入fmt包下的文件），首先执行fmt包中文件中的init()函数；
3、pkg为自动生成的平台静态库；
4、Go语言工程目录：
src目录（必须有），存放源代码 *.go
pkg目录（会自动生成），存放静态库
bin目录（会自动生成），存放可执行程序 *.exe
5、如果有多个文件或者多个包：
①配置GOPATH环境变量，即 src的父目录；
②要想自动生成bin和pkg目录，需要使用 go install命令，执行该命令前，需要配置GOBIN环境变量

7、数组
数组值做参数是值拷贝，即新开辟一块内存空间保存数组参数，操作的是新开辟的数组空间，不是原来的空间
数组指针做函数参数，在函数中操作的是原数组内存空间
数组缺点：大小固定，必须用常数指定长度[5]

7.4、slice
slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array
一样，只是不需要长度，例如
数组：a := [3]int{1,2,3}
切片：a := []int{1,2,3}

7.5 map
7.6.6 可见性
要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头。





